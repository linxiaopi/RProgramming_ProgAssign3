shape_mat
class(shape_mat)
str(shape_mat)
unique(c(3, 4, 5, 5, 5, 6, 6))
uniue_vals <- lapply(flags, unique)
unique_vals <- lapply(flags, unique)
unique_vals
sapply(unique_vals, length)
class(sapply(unique_vals, length))
str(sapply(unique_vals, length))
sapply(flags, unique)
lapply(unique_cals, function(elem) elem[2])
lapply(unique_vals, function(elem) elem[2])
play()
viewinfo(flags)
viewinfo()
nxt()
sapply(flags, unique)
vapply(flags, unique, numeric(1))
ok()
sapply(flags, class)
vapply(flags, class, character(1))
play()
vapply(flag_colors, mean)
vapply(flag_colors, mean, numeric(1))
vapply(flag_colors, mean, integer(1))
vapply(flag_colors, mean, numeric(1))
nxt()
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
tapply(flags$population, flags)
tapply(flags$population, flags$red, summary)
tapply(flags$population, flags$landmass, summary)
library(datasets)
data(iris)
?iris
head(iris)
tapply(iris$Sepal.Length, iris$Species, mean)
class(tapply(iris$Sepal.Length, iris$Species, mean))
class(iris)
apply(iris,[, 1:4], 2, mean)
apply(iris[ , 1:4], 2, mean)
apply(iris[ , 1:4], 1, mean)
class(apply(iris[ , 1:4], 1, mean))
class(apply(iris[ , 1:4], 2, mean))
apply(iris, 2, mean)
colMeans(iris)
rowMeans(iris[ , 1:4])
colMeans(iris[ , 1:4])
library(datasets)
data(mtcars)
?mtcars
head(mtcars)
class(mtcars)
str(mtcars)
head(mtcars[, 1])
apply(mtcars, 2, mean)
mean(mtcars$mpg, mtcars$cyl)
with(mtcars, tapply(mpg, cyl, mean))
tapply(mtcars$mpg, mtcars$cyl, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
split(mtcars, mtcars$cyl)
lapply(mtcars, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(mtcars, cyl, mean)
mhp <- tapply(mtcars$hp, mtcars$cyl, mean)
mhp
str(mhp)
mhp$8
mhp["8"]
mhp["8"] - mhp["4"]
209.21429-82.63636
debug(ls)
ls
?ls
debug(ls)
ls(nothing)
q
q()
exit()
?
ls(mtcars)
ls()
x <- 16:30
length(x)
x[13:15]
x[(length(x)-2:length(x))]
x[(length(x)-2):length(x)]
x[(length(x)-2:length(x))]
x[(length(x)-2]
x[(length(x)-2:15]
x[(length(x)-2)]
x[(length(x)-2:15)]
x[(2:15)]
x[(15-2:15)]
x[((15-2):15)]
x[15-2]
x[15-3]
x[15-4]
x[15-5]
x[15-15]
x[15-14]
ls()
rm(ls)
rm(ls())
rm(list=ls())
x -2
x =2
rm(x)
library(datasets)
data(mtcars)
?data
data()
data(USDSA)
library(.)
theCol <- "cyl"
theCol
mtcars[[theCol]]
mtcars$cyl
mtcars[[theCol]]
str(mtcars)
mtcars[[2]]
mtcars[[2,]]
class(mtcars)
class(mtcars$cyl)
mtcars[, theCol]
mtcars[[theCol]]
mtcars$cyl
mtcars$theCol
head(mtcars[ , 1:3])
theCols <- c("mpg", "cyl", "disp")
head(mtcars[ , theCols])
mtcars[20:22, ]
head(mtcars[mtcars$cyl == 4 & mtcars$am == 1,])
head(mtcars[ , "cyl"])
head(mtcars[ , "cyl"] == 4, ])
head(mtcars[mtcars[ , "cyl"] == 4, ])
theSubsetRows <- which(mtcars$cyl == 4)
head(mtcars[theSubsetRows, ])
theSubsetRows
head(mtcars[!is.na(mtcars[ , "cyl"]), ])
mtcars[!is.na(mtcars[ , "cyl"]), ]
mtcars
is.nat(mtcars$cyl)
is.na(mtcars$cyl)
which(is.na(mtcars$cyl))
which(!is.na(mtcars$cyl))
str(mtcars)
?[
?"["
system.time() #
RProf() #
mtcars[4]
str(mtcars)
mtcars[[4]]
class(mtcars[[4]])
class(mtcars[4])
mtcars[1:5, "cyl"]
head(mtcars[1:5, "cyl"])
class(mtcars[1:5, "cyl"])
mtcars[, "cyl"]
mtcars[, 1:4]
head(mtcars[, 1:4])
class(mtcars[, 1:4])
mtcars[5]
mtcars[[5]]
4 %in% mtcars$cyl
3 %in% mtcars$cyl
3 %in% mtcars$cyl[1:5]
4 %in% mtcars$cyl[1:5]
4 %in% mtcars$cyl[c(1:5)]
mtcars[mtcars$cyl %in% c(1:5)]
mtcars[mtcars$cyl %in% c(1:5)l ]
mtcars[mtcars$cyl %in% c(1:5), ]
mtcars[mtcars$cyl %in% c(1), ]
mtcars[mtcars$cyl %in% c(1,5), ]
mtcars
mtcars[mtcars$cyl %in% c(1,3), ]
mtcars[mtcars$cyl %in% c(1,4), ]
mtcars[mtcars$cyl %in% c(1:5), ]
which(mtcars$cyl == 4)
?which
which(mtcars == "cyl")
which(11 <- c(T,F,T,NA,F,F,T))
which(ll <- c(TRUE, FALSE, TRUE, NA, FALSE, FALSE, TRUE)) #> 1 3 7
which(ll <- c(TRUE, FALSE, TRUE, NA, FALSE, FALSE, TRUE))
11
rm(theCol*)
rm(theCol)
rm(theCols)
rm(theSubsetRows)
names(11)
names(11) <- letters[seq(11)]
which(LETTERS == "R")
LETTERS
names(11) <- letters[seq(11)]
names(ll) <- letters[seq(ll)]
ll
which(ll)
letters
LETTERS
which(ll)
which((1:12)%%2 == 0)
%%2 == 0 %in% 1:12
1:12%%2 == 0 %in% 1:12
which(1:10 > 3, arr.ind = TRUE)
class(which(1:10 > 3, arr.ind = TRUE))
str(which(1:10 > 3, arr.ind = TRUE))
str(which(1:10 > 3, arr.ind = FALSE))
class(which(1:10 > 3, arr.ind = FALSE))
which(1:10 > 3, arr.ind = F)
which(mtcars$cyl == 4)
mtcars[ , which(mtcars$cyl == 4)]
mtcars[which(mtcars$cyl == 4), ]
?"<<-"
x <- 5
x
median(x = 1:10)
rm(x)
median(x = 1:10)
median(x = 1:10)
x
median(test = 1:10)
median(test <- 1:10)
rm(test)
test
x
median(x = 1:10)
median(test <- 1:10)
rm(test)
median(test = 1:10)
test  <- c(100:200)
test
median(test <- 1:10)
test
a <- 1
f <- function(a) return(TRUE)
f <- f(a <- a + 1); a
a <- 1
f <- function(a) return(TRUE)
f(a <- a + 1)
a
a  <- a + 1
a
f(a <- a + 1)
test
median(test <- test + 100)
test
a <- b <- c <- 6
a <- b <- 6 <- c
rm(c)
a <- b <- 6 <- c
rm(a)
rm(b)
a <- b <- 6 <- c
6 -> c -> b -> a
rm(list = ls())
set()
?set
m <- NULL
m
class(m)
?get
get <- c(1,2,3)
get
rm(get)
rm(m)
x  <- c(100:200)
x
get <- function() x
y  <- c(0:100)
get(x)
get
get()
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
list(set = set)
makeVector(c(1,2,3))
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
list(set = set)
}
makeVector(c(1,2,3))
rm(list=ls())
set <- function(y) {
x <<- y
m <<- NULL
}
set()
set(3)
get <- function() x
get
get()
rm(list=ls())
?message
?return
(function(x, y){ z <- x^2 + y^2; x+y+z })
(function(x, y){ z <- x^2 + y^2; x+y+z })(0:7, 1)
setwd "C:/Users/John/git/R_Programming/ProgrammingAssignment2"
pwd
getwd
getwd()
m <- matrix(c(0, 2, 1, 0), nrow = 2, ncol = 2, byrow = TRUE)
m
m + m
m %*% m
## Creates a function that will create an object to store a matrix and its
## inverse along with functions within the object to set and retrieve them;
## creates another function that computes the inverse and caches it in the
## object, or retrieves the inverse from the cache
## Store matrix and create object to cache inverse of matrix
makeCacheMatrix <- function(x = matrix()) {
Inv <- NULL
set <- function(y) {
x <<- y
Inv <<- NULL
}
get <- function() x
setI <- function(inv) {
Inv <<- inv
}
getI <- function() Inv
list(set = set, get = get, setI = setI, getI = getI)
}
## Retrieve cahced inverse of matrix or compute inverse of matrix and cache it
## in makeCacheMatrix if nothing cached
cacheSolve <- function(x, ...) {
Inv <- x$getI()
if(!is.null(Inv)) {
message("Getting cached data")
return(Inv)
}
data <- x$get()
Inv <- solve(data, ...)
x$setI(Inv)
Inv
}
a <- makeCacheMatrix(matrix(1:4, 2, 2))
a
a$get()
cacheSolve(a)
cacheSolve(a)
a$set(matrix(2:5, 2, 2)
)
a$get()
cacheSolve(a)
cacheSolve(a)
library(swirl)
swirl()
play()
set.seed(1)
rpois(5,2)
set.seed(10)
x <- rep(0:1, each = 5)
x
e <- rnorm(10, 0 ,20)
e
y  <- 0.5 + 2 * x + e
y
nxt()
ls()
class(plants)
dim(plants)
nrow(plants)
nco(plants)
ncol(plants)
object.size(plants)
names(plants)
head(plants)
head(plants, 10)
tail(plants, 15)
summary(plants)
table(plants$Active_Growth_Period)
str(plants)
?sample
sample(1:6, 4, replace = TRUE)
sample(1:6, 4, replace = TRUE)
sample(1:20, 10)
LETTERS
sample(LETTERS)
sample(c(0, 1), 100, replacement = TRUE, prob = c(0.3, 0.7))
sample(c(0, 1), 100, replace = TRUE, prob = c(0.3, 0.7))
sample(c(0, 1), 100, replace = TRUE, prob = c(0.3, 0.7))
flips <- sample(c(0, 1), 100, replace = TRUE, prob = c(0.3, 0.7))
flips
sum(flips[flips == 1])
sum(flips)
?rbinom
rbinom(1, size = 100, prob = 0.7)
flips2 <- rbion(100, 1, prob = 0.7)
flips2 <- rbinom(100, 1, prob = 0.7)
flips2
sum(flips2)
?rnorm
rnorm(10)
rnorm(10, mean = 100, sd = 25)
?rpois
rpois(5, 10)
replicate(100, rpois(5,10))
my_pois <- replicate(100, rpois(5,10))
my_pois
cm <- colMeans(my_pois)
hist(cm)
?hist
swirl()
data(cars)
?cars
head(cars)
play()
rm(list=ls())
data(cars)
str(cars)
nxt()
plot(cars)
?plot
plot(x = cars$speed, cars$dist)
plot(x = cars$dist, cars$speed)
plot(x = cars$speed, cars$dist)
plot(x = cars$speed, cars$dist, xlab = "Speed")
plot(x = cars$speed, cars$dist, xlab = "Speed", ylab = "Stopping Distance")
plot(x = cars$speed, cars$dist,  ylab = "Stopping Distance")
plot(x = cars$speed, cars$dist, xlab = "Speed", ylab = "Stopping Distance")
plot(x = cars$speed, cars$dist, main = "My Plot")
plot(cars, main = "My Plot")
plot(cars, sub = "My Plot Subtitle")
plot(cars, col = 2)
plot(cars, xlim = c(10, 15))
?points
plot(cars, pch = 2)
data(mtcars)
play()
str(mtcars)
nxt()
?boxplot
boxplot()
boxplot(formula = mpg ~ cyl, data = mtcars)
hist(mtcars$mpg)
setwd("c:/users/linxiaopi/documents/dropbox/public/[Data Science specialization]/2_RProgramming")
setwd("assign3")
getwd()
data <- read.csv("../assign_3_data/outcome-of-care-measures.csv",
na.strings = "Not Available")
# subset to remove NAs, sort by outcome and alphabetize data
sub <- data[!is.na(data[ , 11]), ]
sub <- sub[order(sub[ , 7], sub[ , 11], sub$Hospital.Name) , ]
sub <- sub[ , c(2, 7, 11)]
names(sub) <- c("hospital","st", "rate")
sub$rank <- unlist(tapply(sub$rate, sub$st, seq_along))
# get list of hospitals with rank of "num"
lsth <- lapply(sub, function(x) x[which(sub$rank == 1)])
lsth
class(lsth)
lsth$hospital
lsth$hospital$1
lsth$hospital[1]
lsth[1]
lsth[1]$1
lsth[1][1]
lsth[1][1,]
class(lsth[1])
class(lsth[2])
class(lsth$hospital)
class(lsth$rate)
lsth
class(lsth$rank)
class(lsth$st)
class(sub)
str(sub)
lsth2 <- sapply(sub, function(x) x[which(sub$rank == 1)])
lsth2
class(lsth2)
lsth
lsth3 <- lapply(sub, function(x) x[which(sub$rank == 1)])
lsth3
str(lsth2)
head(lsth2)
lsth2 <- sapply(sub, function(x) x[which(x$rank == 1)])
lsth2 <- sapply(sub, function(x) x[which(x[4] == 1)])
lsth2
sub[1:5,]
class(lsth2)
lsth2
new <- as.data.frame(lsth2[c(1:2])
new <- as.data.frame(lsth2[1:2])
new
str(new)
new <- as.data.frame(lsth2)
new
?data.frame
data.frame(x=1, y=1:10)
data.frame(1, 1:10)
data.frame(lsth2[1], lsth2[2])
lsth2[1]
lsth2
lsth <- lapply(sub, function(x) x[which(x[4] == 1)])
lsth
lsth <- lapply(sub, function(x) x[which(x$rate == 1)])
lsth <- lapply(sub, function(x) x[which(sub$rate == 1)])
lsth
lsth <- lapply(sub, function(x) x[which(sub$rate == 1)])
lsth
